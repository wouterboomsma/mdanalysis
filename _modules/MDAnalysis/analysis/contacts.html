<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MDAnalysis.analysis.contacts &mdash; MDAnalysis 0.14.1-dev0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.14.1-dev0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.14.1-dev0 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="top" title="MDAnalysis 0.14.1-dev0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.14.1-dev0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/mdanalysis-logo-200x150.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for MDAnalysis.analysis.contacts</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c1"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4</span>
<span class="c1">#</span>
<span class="c1"># MDAnalysis --- http://www.MDAnalysis.org</span>
<span class="c1"># Copyright (c) 2006-2015 Naveen Michaud-Agrawal, Elizabeth J. Denning, Oliver Beckstein</span>
<span class="c1"># and contributors (see AUTHORS for the full list)</span>
<span class="c1">#</span>
<span class="c1"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c1">#</span>
<span class="c1"># Please cite your use of MDAnalysis in published work:</span>
<span class="c1">#</span>
<span class="c1"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c1"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c1">#</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Native contacts analysis --- :mod:`MDAnalysis.analysis.contacts`</span>
<span class="sd">================================================================</span>

<span class="sd">Analysis of native contacts *q* over a trajectory.</span>

<span class="sd">* a &quot;contact&quot; exists between two atoms *i* and *j* if the distance between them is</span>
<span class="sd">  smaller than a given *radius*</span>

<span class="sd">* a &quot;native contact&quot; exists between *i* and *j* if a contact exists and if the</span>
<span class="sd">  contact also exists between the equivalent atoms in a reference structure or</span>
<span class="sd">  conformation</span>

<span class="sd">The &quot;fraction of native contacts&quot; *q(t)* is a number between 0 and 1 and</span>
<span class="sd">calculated as the total number of native contacts for a given time frame</span>
<span class="sd">divided by the total number of contacts in the reference structure.</span>

<span class="sd">Classes are available for two somewhat different ways to perform a contact</span>
<span class="sd">analysis:</span>

<span class="sd">1. Contacts between two groups of atoms are defined with</span>
<span class="sd">   :class:`ContactAnalysis1`), which allows one to calculate *q(t)* over</span>
<span class="sd">   time. This is especially useful in order to look at native contacts during</span>
<span class="sd">   an equilibrium simulation where one can also look at the average matrix of</span>
<span class="sd">   native contacts (see :meth:`ContactAnalysis1.plot_qavg`).</span>

<span class="sd">2. Contacts are defined within one group in a protein (e.g. all C-alpha atoms)</span>
<span class="sd">   but relative to *two different conformations* 1 and 2, using</span>
<span class="sd">   :class:`ContactAnalysis`. This allows one to do a *q1-q2* analysis that</span>
<span class="sd">   shows how native contacts of state 1 change in comparison to native contacts</span>
<span class="sd">   of state 2.  Transition pathways have been analyzed in terms of these two</span>
<span class="sd">   variables q1 and q2 that relate to the native contacts in the end states of</span>
<span class="sd">   the transition.</span>

<span class="sd">.. SeeAlso:: See http://lorentz.dynstr.pasteur.fr/joel/adenylate.php for an</span>
<span class="sd">   example of contact analysis applied to MinActionPath trajectories of AdK</span>
<span class="sd">   (although this was *not* performed with MDAnalysis --- it&#39;s provided as a</span>
<span class="sd">   very good illustrative example).</span>


<span class="sd">Examples</span>
<span class="sd">--------</span>

<span class="sd">One-dimensional contact analysis</span>
<span class="sd">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="sd">As an example we analyze the opening (&quot;unzipping&quot;) of salt bridges</span>
<span class="sd">when the AdK enzyme opens up; this is one of the example trajectories</span>
<span class="sd">in MDAnalysis. ::</span>

<span class="sd">    import MDAnalysis</span>
<span class="sd">    import MDAnalysis.analysis.contacts</span>
<span class="sd">    from MDAnalysis.tests.datafiles import PSF,DCD</span>

<span class="sd">    # example trajectory (transition of AdK from closed to open)</span>
<span class="sd">    u = MDAnalysis.Universe(PSF,DCD)</span>

<span class="sd">    # crude definition of salt bridges as contacts between NH/NZ in ARG/LYS and OE*/OD* in ASP/GLU.</span>
<span class="sd">    # You might want to think a little bit harder about the problem before using this for real work.</span>
<span class="sd">    sel_basic = &quot;(resname ARG or resname LYS) and (name NH* or name NZ)&quot;</span>
<span class="sd">    sel_acidic = &quot;(resname ASP or resname GLU) and (name OE* or name OD*)&quot;</span>

<span class="sd">    # reference groups (first frame of the trajectory, but you could also use a separate PDB, eg crystal structure)</span>
<span class="sd">    acidic = u.select_atoms(sel_acidic)</span>
<span class="sd">    basic = u.select_atoms(sel_basic)</span>

<span class="sd">    # set up analysis of native contacts (&quot;salt bridges&quot;); salt bridges have a distance &lt;6 A</span>
<span class="sd">    CA1 = MDAnalysis.analysis.contacts.ContactAnalysis1(u, selection=(sel_acidic, sel_basic), refgroup=(acidic,</span>
<span class="sd">    basic), radius=6.0, outfile=&quot;qsalt.dat&quot;)</span>

<span class="sd">    # iterate through trajectory and perform analysis of &quot;native contacts&quot; q</span>
<span class="sd">    # (force=True ignores any previous results, force=True is useful when testing)</span>
<span class="sd">    CA1.run(force=True)</span>

<span class="sd">    # plot time series q(t) [possibly do &quot;import pylab; pylab.clf()&quot; do clear the figure first...]</span>
<span class="sd">    CA1.plot(filename=&quot;adk_saltbridge_contact_analysis1.pdf&quot;, linewidth=3, color=&quot;blue&quot;)</span>

<span class="sd">    # or plot the data in qsalt.dat yourself.</span>
<span class="sd">    CA1.plot_qavg(filename=&quot;adk_saltbridge_contact_analysis1_matrix.pdf&quot;)</span>

<span class="sd">The first graph shows that when AdK opens, about 20% of the salt</span>
<span class="sd">bridges that existed in the closed state disappear when the enzyme</span>
<span class="sd">opens. They open in a step-wise fashion (made more clear by the movie</span>
<span class="sd">`AdK_zipper_cartoon.avi`_).</span>

<span class="sd">The output graphs can be made prettier but if you look at the code</span>
<span class="sd">itself then you&#39;ll quickly figure out what to do. The qavg plot is the</span>
<span class="sd">matrix of all contacts, averaged over the trajectory. This plot makes</span>
<span class="sd">more sense for an equilibrium trajectory than for the example above</span>
<span class="sd">but is is included for illustration.</span>

<span class="sd">See the docs for :class:`ContactAnalysis1` for another example.</span>


<span class="sd">.. AdK_zipper_cartoon.avi:</span>
<span class="sd">   http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2803350/bin/NIHMS150766-supplement-03.avi</span>

<span class="sd">Two-dimensional contact analysis (q1-q2)</span>
<span class="sd">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="sd">Analyze a single DIMS transition of AdK between its closed and open</span>
<span class="sd">conformation and plot the trajectory projected on q1-q2::</span>

<span class="sd">  import MDAnalysis.analysis.contacts</span>
<span class="sd">  from MDAnalysis.tests.datafiles import PSF, DCD</span>
<span class="sd">  C = MDAnalysis.analysis.contacts.ContactAnalysis(PSF, DCD)</span>
<span class="sd">  C.run()</span>
<span class="sd">  C.plot()</span>

<span class="sd">Compare the resulting pathway to the `MinActionPath result for AdK`_.</span>

<span class="sd">.. _MinActionPath result for AdK:</span>
<span class="sd">   http://lorentz.dynstr.pasteur.fr/joel/adenylate.php</span>

<span class="sd">Classes</span>
<span class="sd">-------</span>

<span class="sd">.. autoclass:: Contacts</span>
<span class="sd">   :members:</span>
<span class="sd">.. autoclass:: ContactAnalysis</span>
<span class="sd">   :members:</span>


<span class="sd">Deprecated</span>
<span class="sd">----------</span>

<span class="sd">.. autoclass:: ContactAnalysis1</span>
<span class="sd">   :members:</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">errno</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">bz2</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="kn">import</span> <span class="nb">zip</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">MDAnalysis</span>
<span class="kn">import</span> <span class="nn">MDAnalysis.lib.distances</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib.util</span> <span class="kn">import</span> <span class="n">openany</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.analysis.distances</span> <span class="kn">import</span> <span class="n">distance_array</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">AnalysisBase</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;MDAnalysis.analysis.contacts&quot;</span><span class="p">)</span>


<span class="c1"># ContactAnalysis needs to be cleaned up and possibly renamed but</span>
<span class="c1"># until then it remains because we don&#39;t have the functionality</span>
<span class="c1"># elsewhere.</span>

<div class="viewcode-block" id="ContactAnalysis"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis">[docs]</a><span class="k">class</span> <span class="nc">ContactAnalysis</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform a native contact analysis (&quot;q1-q2&quot;).</span>

<span class="sd">    The analysis of the trajectory is performed with the</span>
<span class="sd">    :meth:`ContactAnalysis.run` method. The result is stored in</span>
<span class="sd">    :attr:`ContactAnalysis.timeseries`. It is a numpy array which</span>
<span class="sd">    contains the frame number at index 0, q1 and q2 at index 1 and 2,</span>
<span class="sd">    and the total number of contacts in 3 and 4. ::</span>

<span class="sd">        frame  q1 q2  n1 n2</span>

<span class="sd">    The total number of contacts in the reference states 1 and 2 are</span>
<span class="sd">    stored in :attr:`ContactAnalysis.nref` (index 0 and 1).</span>

<span class="sd">    The :meth:`ContactAnalysis.run` method calculates the percentage of native</span>
<span class="sd">    contacts *q1* and *q2* along a trajectory. &quot;Contacts&quot; are defined as the</span>
<span class="sd">    number of Ca atoms (or per-residue *centroids* of a user defined</span>
<span class="sd">    *selection*) within *radius* of a primary Ca. *q1* is the fraction of</span>
<span class="sd">    contacts relative to the reference state 1 (typically the starting</span>
<span class="sd">    conformation of the trajectory) and *q2* is the fraction of contacts</span>
<span class="sd">    relative to the conformation 2.</span>

<span class="sd">    The timeseries is written to a bzip2-compressed file in `targetdir`</span>
<span class="sd">    named &quot;basename(trajectory)infix_q1q2.dat.bz2&quot; and is also</span>
<span class="sd">    accessible as the attribute</span>
<span class="sd">    :attr:`ContactAnalysis.timeseries`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topology</span><span class="p">,</span> <span class="n">trajectory</span><span class="p">,</span> <span class="n">ref1</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ref2</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>
                 <span class="n">targetdir</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">curdir</span><span class="p">,</span> <span class="n">infix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">selection</span><span class="o">=</span><span class="s2">&quot;name CA&quot;</span><span class="p">,</span> <span class="n">centroids</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate native contacts from two reference structures.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        topology : filename</span>
<span class="sd">            topology file</span>
<span class="sd">        trajectory : filename</span>
<span class="sd">            trajectory</span>
<span class="sd">        ref1 : filename or ``None``, optional</span>
<span class="sd">            structure of the reference conformation 1 (pdb); if ``None`` the *first*</span>
<span class="sd">            frame of the trajectory is chosen</span>
<span class="sd">        ref2 : filename or ``None``, optional</span>
<span class="sd">            structure of the reference conformation 2 (pdb); if ``None`` the *last*</span>
<span class="sd">            frame of the trajectory is chosen</span>
<span class="sd">        radius : float, optional, default 8 A</span>
<span class="sd">            contacts are deemed any Ca within radius</span>
<span class="sd">        targetdir : path, optional, default ``.``</span>
<span class="sd">            output files are saved in this directory</span>
<span class="sd">        infix : string, optional</span>
<span class="sd">            additional tag string that is inserted into the output filename of the</span>
<span class="sd">            data file</span>
<span class="sd">         selection : string, optional, default ``&quot;name CA&quot;``</span>
<span class="sd">            MDAnalysis selection string that selects the particles of</span>
<span class="sd">            interest; the default is to only select the C-alpha atoms</span>
<span class="sd">            in `ref1` and `ref2`</span>

<span class="sd">            .. Note:: If `selection` produces more than one atom per</span>
<span class="sd">                      residue then you will get multiple contacts per</span>
<span class="sd">                      residue unless you also set `centroids` = ``True``</span>
<span class="sd">         centroids : bool</span>
<span class="sd">            If set to ``True``, use the centroids for the selected atoms on a</span>
<span class="sd">            per-residue basis to compute contacts. This allows, for instance</span>
<span class="sd">            defining the sidechains as `selection` and then computing distances</span>
<span class="sd">            between sidechain centroids.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">topology</span> <span class="o">=</span> <span class="n">topology</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span> <span class="o">=</span> <span class="n">trajectory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span> <span class="o">=</span> <span class="n">targetdir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">force</span> <span class="o">=</span> <span class="n">force</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="n">selection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centroids</span> <span class="o">=</span> <span class="n">centroids</span>

        <span class="n">trajectorybase</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">trajectory</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">trajectorybase</span> <span class="o">+</span> <span class="n">infix</span> <span class="o">+</span> <span class="s1">&#39;_q1q2.dat&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_bz2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">+</span> <span class="s1">&#39;.bz2&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1"># final result</span>

        <span class="c1"># short circuit if output file already exists: skip everything</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_exists</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">return</span>  <span class="c1"># do not bother reading any data or initializing arrays... !!</span>
        <span class="c1"># don&#39;t bother if trajectory is empty (can lead to segfaults so better catch it)</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">trajectory</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stats</span><span class="o">.</span><span class="n">st_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;trajectory = {trajectory!s} is empty, skipping...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="nb">vars</span><span class="p">()))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">return</span>
        <span class="c1"># under normal circumstances we do not skip</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c1"># expensive initialization starts with building Universes :-)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Universe</span><span class="p">(</span><span class="n">topology</span><span class="p">,</span> <span class="n">trajectory</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ref1</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ref1</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span><span class="p">,</span> <span class="n">trajectorybase</span> <span class="o">+</span> <span class="s1">&#39;_first.pdb&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># extract first frame</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ref1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref1</span> <span class="o">=</span> <span class="n">ref1</span>
        <span class="k">if</span> <span class="n">ref2</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ref2</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span><span class="p">,</span> <span class="n">trajectorybase</span> <span class="o">+</span> <span class="s1">&#39;_last.pdb&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># extract last frame</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ref2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># rewind, just in case...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref2</span> <span class="o">=</span> <span class="n">ref2</span>

        <span class="n">r1</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Universe</span><span class="p">(</span><span class="n">topology</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref1</span><span class="p">)</span>
        <span class="n">r2</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Universe</span><span class="p">(</span><span class="n">topology</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref2</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">)</span>
        <span class="n">ca1</span> <span class="o">=</span> <span class="n">r1</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">)</span>
        <span class="n">ca2</span> <span class="o">=</span> <span class="n">r2</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">)</span>

        <span class="c1"># NOTE: self_distance_array() produces a 1D array; this works here</span>
        <span class="c1">#       but is not the same as the 2D output from distance_array()!</span>
        <span class="c1">#       See the docs for self_distance_array().</span>
        <span class="n">dref</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_distance_array</span><span class="p">(</span><span class="n">ca1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_distance_array</span><span class="p">(</span><span class="n">ca2</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qref</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">qarray</span><span class="p">(</span><span class="n">dref</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">qarray</span><span class="p">(</span><span class="n">dref</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nref</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">qref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">qref</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">dref</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qtmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">)</span>  <span class="c1"># pre-allocated array</span>

<div class="viewcode-block" id="ContactAnalysis.get_distance_array"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis.get_distance_array">[docs]</a>    <span class="k">def</span> <span class="nf">get_distance_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the self_distance_array for atoms in group *g*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        g : AtomGroup</span>
<span class="sd">              group of atoms to calculate distance array for</span>
<span class="sd">        results : array, optional</span>
<span class="sd">              passed on to :func:`MDAnalysis.lib.distances.self_distance_array`</span>
<span class="sd">              as a preallocated array</span>
<span class="sd">        centroids : bool, optional, default ``None``</span>
<span class="sd">              ``True``: calculate per-residue centroids from the selected atoms;</span>
<span class="sd">              ``False``: consider each atom separately; ``None``: use the class</span>
<span class="sd">              default for *centroids* [``None``]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;centroids&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroids</span> <span class="k">if</span> <span class="n">centroids</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">centroids</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">centroids</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">positions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># centroids per residue (but only including the selected atoms)</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">residue</span><span class="o">.</span><span class="n">centroid</span><span class="p">()</span> <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;residue&quot;</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">self_distance_array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="ContactAnalysis.output_exists"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis.output_exists">[docs]</a>    <span class="k">def</span> <span class="nf">output_exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if default output file already exists.</span>

<span class="sd">        Disable with force=True (will always return False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">)</span> <span class="ow">or</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_bz2</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">force</span> <span class="ow">or</span> <span class="n">force</span><span class="p">)</span></div>

<div class="viewcode-block" id="ContactAnalysis.run"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Analyze trajectory and produce timeseries.</span>

<span class="sd">        Stores results in :attr:`ContactAnalysis.timeseries` (if</span>
<span class="sd">        store=True) and writes them to a bzip2-compressed data file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_exists</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;File {output!r} or {output_bz2!r} already exists, loading {trajectory!r}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_bz2</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="n">outbz2</span> <span class="o">=</span> <span class="n">bz2</span><span class="o">.</span><span class="n">BZ2File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_bz2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">buffering</span><span class="o">=</span><span class="mi">8192</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">outbz2</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;# q1-q2 analysis</span><span class="se">\n</span><span class="s2"># nref1 = {0:d}</span><span class="se">\n</span><span class="s2"># nref2 = {1:d}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nref</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">nref</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">outbz2</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;# frame  q1  q2   n1  n2</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">records</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">:</span>
                <span class="n">frame</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">frame</span>
                <span class="c1"># use pre-allocated distance array to save a little bit of time</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_distance_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ca</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">)</span>
                <span class="n">n1</span><span class="p">,</span> <span class="n">q1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qN</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_qtmp</span><span class="p">)</span>
                <span class="n">n2</span><span class="p">,</span> <span class="n">q2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qN</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_qtmp</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
                    <span class="n">records</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">frame</span><span class="p">,</span> <span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">))</span>
                <span class="n">outbz2</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;{frame:4d}  {q1:8.6f} {q2:8.6f}  {n1:5d} {n2:5d}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="nb">vars</span><span class="p">()))</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">outbz2</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">records</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_bz2</span></div>

<div class="viewcode-block" id="ContactAnalysis.qarray"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis.qarray">[docs]</a>    <span class="k">def</span> <span class="nf">qarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return array with ``True`` for contacts.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This method is typically only used internally.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        d : array</span>
<span class="sd">          2D array of distances. The method uses the value of</span>
<span class="sd">          :attr:`radius` to determine if a ``distance &lt; radius``</span>
<span class="sd">          is considered a contact.</span>
<span class="sd">        out : array, optional</span>
<span class="sd">          If `out` is supplied as a pre-allocated array of the correct</span>
<span class="sd">          shape then it is filled instead of allocating a new one in</span>
<span class="sd">          order to increase performance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array</span>
<span class="sd">           contact matrix</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="ContactAnalysis.qN"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis.qN">[docs]</a>    <span class="k">def</span> <span class="nf">qN</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate native contacts relative to reference state.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This method is typically only used internally.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        q : array</span>
<span class="sd">          contact matrix (see :meth:`Contacts.qarray`)</span>
<span class="sd">        out : array, optional</span>
<span class="sd">          If `out` is supplied as a pre-allocated array of the correct</span>
<span class="sd">          shape then it will contain the contact matrix relative</span>
<span class="sd">          to the reference state, i.e. only those contacts that</span>
<span class="sd">          are also seen in the reference state.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        contacts : integer</span>
<span class="sd">           total number of contacts</span>
<span class="sd">        fraction : float</span>
<span class="sd">           fraction of contacts relative to the reference state</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qref</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qref</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">out</span><span class="p">)</span>
        <span class="n">contacts</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">contacts</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">contacts</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nref</span><span class="p">[</span><span class="n">n</span><span class="p">]</span></div>

<div class="viewcode-block" id="ContactAnalysis.load"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load the data file.&quot;&quot;&quot;</span>
        <span class="n">records</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">openany</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">records</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">records</span><span class="p">)</span><span class="o">.</span><span class="n">T</span></div>

<div class="viewcode-block" id="ContactAnalysis.plot"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot q1-q2.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="n">plot</span><span class="p">,</span> <span class="n">xlabel</span><span class="p">,</span> <span class="n">ylabel</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;black&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No timeseries data; do &#39;ContactAnalysis.run(store=True)&#39; first.&quot;</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span>
        <span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">xlabel</span><span class="p">(</span><span class="s2">r&quot;$q_1$&quot;</span><span class="p">)</span>
        <span class="n">ylabel</span><span class="p">(</span><span class="s2">r&quot;$q_2$&quot;</span><span class="p">)</span></div></div>


<span class="c1"># ContactAnalysis1 is a (hopefully) temporary hack. It should be unified with ContactAnalysis</span>
<span class="c1"># or either should be derived from a base class because many methods are copy&amp;paste with</span>
<span class="c1"># minor changes (mostly for going from q1q2 -&gt; q1 only).</span>
<span class="c1"># If ContactAnalysis is enhanced to accept two references then this should be even easier.</span>
<span class="c1"># It might also be worthwhile making a simpler class that just does the q calculation</span>
<span class="c1"># and use it for both reference and trajectory data.</span>
<div class="viewcode-block" id="ContactAnalysis1"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis1">[docs]</a><span class="k">class</span> <span class="nc">ContactAnalysis1</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform a very flexible native contact analysis with respect to a single reference.</span>

<span class="sd">    This analysis class allows one to calculate the fraction of native contacts</span>
<span class="sd">    *q* between two arbitrary groups of atoms with respect to an arbitrary</span>
<span class="sd">    reference structure. For instance, as a reference one could take a crystal</span>
<span class="sd">    structure of a complex, and as the two groups atoms one selects two</span>
<span class="sd">    molecules A and B in the complex. Then the question to be answered by *q*</span>
<span class="sd">    is, is which percentage of the contacts between A and B persist during the simulation.</span>

<span class="sd">    First prepare :class:`~MDAnalysis.core.AtomGroup.AtomGroup` selections for</span>
<span class="sd">    the reference atoms; this example uses some arbitrary selections::</span>

<span class="sd">      ref = Universe(&#39;crystal.pdb&#39;)</span>
<span class="sd">      refA = ref.select_atoms(&#39;name CA and segid A and resid 6:100&#39;)</span>
<span class="sd">      refB = ref.select_atoms(&#39;name CA and segid B and resid 1:40&#39;)</span>

<span class="sd">    Load the trajectory::</span>

<span class="sd">      u = Universe(topology, trajectory)</span>

<span class="sd">    We then need two selection strings *selA* and *selB* that, when applied as</span>
<span class="sd">    ``u.select_atoms(selA)`` produce a list of atoms that is equivalent to the</span>
<span class="sd">    reference (i.e. ``u.select_atoms(selA)`` must select the same atoms as</span>
<span class="sd">    ``refA`` in this example)::</span>

<span class="sd">      selA = &#39;name CA and resid 1:95&#39;     # corresponds to refA</span>
<span class="sd">      selB = &#39;name CA and resid 150:189&#39;  # corresponds to refB</span>

<span class="sd">    .. Note::</span>

<span class="sd">       It is the user&#39;s responsibility to provide a reference group</span>
<span class="sd">       (or groups) that describe equivalent atoms to the ones selected</span>
<span class="sd">       by *selection*.</span>

<span class="sd">    Now we are ready to set up the analysis::</span>

<span class="sd">      CA1 = ContactAnalysis1(u, selection=(selA,selB), refgroup=(refA,refB), radius=8.0, outfile=&quot;q.dat&quot;)</span>

<span class="sd">    If the groups do not match in length then a :exc:`ValueError` is raised.</span>

<span class="sd">    The analysis across the whole trajectory is performed with ::</span>

<span class="sd">      CA1.run()</span>

<span class="sd">    Results are saved to *outfile* (``framenumber q N`` per line) and</span>
<span class="sd">    can also be plotted with ::</span>

<span class="sd">      CA1.plot()        # plots the time series q(t)</span>
<span class="sd">      CA1.plot_qavg()   # plots the matrix of average contacts &lt;q&gt;</span>

<span class="sd">    **Description of computed values** in the output file:</span>

<span class="sd">    *N*</span>
<span class="sd">         number of native contacts</span>

<span class="sd">    *q*</span>
<span class="sd">         fraction of native contacts relative to the reference</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate native contacts within a group or between two groups.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">          *topology*</span>
<span class="sd">            psf or pdb file</span>
<span class="sd">          *trajectory*</span>
<span class="sd">            dcd or xtc/trr file</span>
<span class="sd">          *universe*</span>
<span class="sd">            instead of a topology/trajectory combination, one can also supply</span>
<span class="sd">            a :class:`MDAnalysis.Universe`</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *selection*</span>
<span class="sd">            selection string that determines which distances are calculated; if this</span>
<span class="sd">            is a tuple or list with two entries then distances are calculated between</span>
<span class="sd">            these two different groups [&quot;name CA or name B*&quot;]</span>
<span class="sd">          *refgroup*</span>
<span class="sd">            reference group, either a single :class:`~MDAnalysis.core.AtomGroup.AtomGroup`</span>
<span class="sd">            (if there is only a single *selection*) or a list of two such groups.</span>
<span class="sd">            The reference contacts are directly computed from *refgroup* and hence</span>
<span class="sd">            the atoms in the reference group(s) must be equivalent to the ones produced</span>
<span class="sd">            by the *selection* on the input trajectory.</span>
<span class="sd">          *radius*</span>
<span class="sd">            contacts are deemed any atoms within radius [8.0 A]</span>
<span class="sd">          *outfile*</span>
<span class="sd">            name of the output file; with the gz or bz2 suffix, a compressed</span>
<span class="sd">            file is written. The average &lt;q&gt; is written to a second, gzipped</span>
<span class="sd">            file that has the same name with &#39;array&#39; included. E.g. for the</span>
<span class="sd">            default name &quot;q1.dat.gz&quot; the &lt;q&gt; file will be &quot;q1.array.gz&quot;. The</span>
<span class="sd">            format is the matrix in column-row format, i.e. selection 1</span>
<span class="sd">            residues are the columns and selection 2 residues are rows. The</span>
<span class="sd">            file can be read with :func:`np.loadtxt`.  [&quot;q1.dat.gz&quot;]</span>

<span class="sd">        The function calculates the percentage of native contacts q1</span>
<span class="sd">        along a trajectory. &quot;Contacts&quot; are defined as the number of atoms</span>
<span class="sd">        within *radius* of a given other atom. *q1* is the fraction of contacts</span>
<span class="sd">        relative to the reference state 1 (typically the starting conformation</span>
<span class="sd">        of the trajectory).</span>

<span class="sd">        The timeseries is written to a file *outfile* and is also accessible as</span>
<span class="sd">        the attribute :attr:`ContactAnalysis1.timeseries`.</span>

<span class="sd">        .. deprecated: 0.14.0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># XX or should I use as input</span>
        <span class="c1">#   sel = (group1, group2), ref = (refgroup1, refgroup2)</span>
        <span class="c1"># and get the universe from sel?</span>
        <span class="c1"># Currently it&#39;s a odd hybrid.</span>
        <span class="c1">#</span>
        <span class="c1"># Enhancements:</span>
        <span class="c1"># - select contact pairs to write out as a timecourse</span>
        <span class="c1"># - make this selection based on qavg</span>
        <span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">splitext</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;ContactAnalysis1 is deprecated and will be removed in 1.0. &quot;</span>
                      <span class="s2">&quot;Use Contacts instead.&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">selection_strings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_return_tuple2</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span>
            <span class="s1">&#39;selection&#39;</span><span class="p">,</span> <span class="s2">&quot;name CA or name B*&quot;</span><span class="p">),</span> <span class="s2">&quot;selection&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">references</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_return_tuple2</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;refgroup&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
                                              <span class="s2">&quot;refgroup&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;radius&#39;</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;targetdir&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">curdir</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;outfile&#39;</span><span class="p">,</span> <span class="s2">&quot;q1.dat.gz&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outarray</span> <span class="o">=</span> <span class="n">splitext</span><span class="p">(</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;.array.gz&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">force</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;force&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1"># final result</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filenames</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">as_Universe</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">selections</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection_strings</span><span class="p">]</span>

        <span class="c1"># sanity checkes</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">references</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;a reference AtomGroup must be supplied&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ref</span><span class="p">,</span> <span class="n">sel</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">references</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">selections</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection_strings</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ref</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">n_atoms</span> <span class="o">!=</span> <span class="n">sel</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;selection=</span><span class="si">%r</span><span class="s2">: Number of atoms differ between &quot;</span>
                                 <span class="s2">&quot;reference (</span><span class="si">%d</span><span class="s2">) and trajectory (</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ref</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="n">sel</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">))</span>

        <span class="c1"># compute reference contacts</span>
        <span class="n">dref</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">distance_array</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">references</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">references</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qarray</span><span class="p">(</span><span class="n">dref</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qref</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c1"># setup arrays for the trajectory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">dref</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qtmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">)</span>  <span class="c1"># pre-allocated array</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">qavg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_return_tuple2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%(name)s</span><span class="s2"> must be a single object or a tuple/list with two objects &quot;</span>
                             <span class="s2">&quot;and not </span><span class="si">%(x)r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">())</span>

<div class="viewcode-block" id="ContactAnalysis1.output_exists"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis1.output_exists">[docs]</a>    <span class="k">def</span> <span class="nf">output_exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if default output file already exists.</span>

<span class="sd">        Disable with force=True (will always return False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">force</span> <span class="ow">or</span> <span class="n">force</span><span class="p">)</span></div>

<div class="viewcode-block" id="ContactAnalysis1.run"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis1.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Analyze trajectory and produce timeseries.</span>

<span class="sd">        Stores results in :attr:`ContactAnalysis1.timeseries` (if store=True)</span>
<span class="sd">        and writes them to a data file. The average q is written to a second</span>
<span class="sd">        data file.</span>
<span class="sd">        *start*</span>
<span class="sd">            The value of the first frame index in the trajectory to be used (default: index 0)</span>
<span class="sd">        *stop*</span>
<span class="sd">            The value of the last frame index in the trajectory to be used (default: None -- use all frames)</span>
<span class="sd">        *step*</span>
<span class="sd">            The number of frames to skip during trajectory iteration (default: use every frame)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;start_frame&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;start_frame argument has been deprecated, use start instead --&quot;</span>
                           <span class="s2">&quot;removal targeted for version 0.15.0&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;start_frame&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;end_frame&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;end_frame argument has been deprecated, use stop instead --&quot;</span>
                           <span class="s2">&quot;removal targeted for version 0.15.0&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;end_frame&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;step_value&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;step_value argument has been deprecated, use step instead --&quot;</span>
                           <span class="s2">&quot;removal targeted for version 0.15.0&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;step_value&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_exists</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;File </span><span class="si">%r</span><span class="s2"> already exists, loading it INSTEAD of trajectory </span><span class="si">%r</span><span class="s2">. &quot;</span>
                          <span class="s2">&quot;Use force=True to overwrite the output file. &quot;</span> <span class="o">%</span>
                          <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">filename</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">with</span> <span class="n">openany</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;# q1 analysis</span><span class="se">\n</span><span class="s2"># nref = {0:d}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nref</span><span class="p">)))</span>
            <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;# frame  q1  n1</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">records</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qavg</span> <span class="o">*=</span> <span class="mi">0</span>  <span class="c1"># average contact existence</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selections</span>
            <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">:</span><span class="n">step</span><span class="p">]:</span>
                <span class="n">frame</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">frame</span>
                <span class="c1"># use pre-allocated distance array to save a little bit of time</span>
                <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">distance_array</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">)</span>
                <span class="n">n1</span><span class="p">,</span> <span class="n">q1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qN</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_qtmp</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qavg</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span>
                <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
                    <span class="n">records</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">frame</span><span class="p">,</span> <span class="n">q1</span><span class="p">,</span> <span class="n">n1</span><span class="p">))</span>
                <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;{frame:4d}  {q1:8.6f} {n1:5d}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="nb">vars</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">records</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">n_frames</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">n_frames</span><span class="p">)[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">:</span><span class="n">step</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">n_frames</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qavg</span> <span class="o">/=</span> <span class="n">n_frames</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;No frames were analyzed. Check values of start, stop, step.&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;start={start} stop={stop} step={step}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="nb">vars</span><span class="p">()))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outarray</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qavg</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%8.6f</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span></div>

<div class="viewcode-block" id="ContactAnalysis1.qarray"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis1.qarray">[docs]</a>    <span class="k">def</span> <span class="nf">qarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return distance array with True for contacts.</span>

<span class="sd">        *d* is the matrix of distances. The method uses the value of</span>
<span class="sd">        :attr:`ContactAnalysis1.radius` to determine if a ``distance &lt; radius``</span>
<span class="sd">        is considered a contact.</span>

<span class="sd">        If *out* is supplied as a pre-allocated array of the correct</span>
<span class="sd">        shape then it is filled instead of allocating a new one in</span>
<span class="sd">        order to increase performance.</span>

<span class="sd">        This method is typically only used internally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="ContactAnalysis1.qN"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis1.qN">[docs]</a>    <span class="k">def</span> <span class="nf">qN</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate native contacts relative to reference state.</span>

<span class="sd">        *q* is the matrix of contacts (e.g. :attr:`~ContactAnalysis1.q`).</span>

<span class="sd">        If *out* is supplied as a pre-allocated array of the correct</span>
<span class="sd">        shape then it is filled instead of allocating a new one in</span>
<span class="sd">        order to increase performance.</span>

<span class="sd">        This method is typically only used internally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qref</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qref</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
        <span class="n">contacts</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">contacts</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">contacts</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nref</span></div>

<div class="viewcode-block" id="ContactAnalysis1.load"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis1.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load the data file.&quot;&quot;&quot;</span>
        <span class="n">records</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">openany</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">records</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">records</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qavg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outarray</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">err</span><span class="o">.</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">errno</span><span class="o">.</span><span class="n">ENOENT</span><span class="p">:</span>
                <span class="k">raise</span></div>

<div class="viewcode-block" id="ContactAnalysis1.plot"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis1.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot q(t).</span>

<span class="sd">        .. function:: ContactAnalysis1.plot([filename, ...])</span>

<span class="sd">        If *filename* is supplied then the figure is also written to file (the</span>
<span class="sd">        suffix determines the file type, e.g. pdf, png, eps, ...). All other</span>
<span class="sd">        keyword arguments are passed on to :func:`pylab.plot`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="n">plot</span><span class="p">,</span> <span class="n">xlabel</span><span class="p">,</span> <span class="n">ylabel</span><span class="p">,</span> <span class="n">savefig</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;black&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;linewidth&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No timeseries data; do &#39;ContactAnalysis.run(store=True)&#39; first.&quot;</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span>
        <span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">xlabel</span><span class="p">(</span><span class="s2">r&quot;frame number $t$&quot;</span><span class="p">)</span>
        <span class="n">ylabel</span><span class="p">(</span><span class="s2">r&quot;native contacts $q_1$&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_plot_qavg_pcolor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot :attr:`ContactAnalysis1.qavg`, the matrix of average native contacts.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="n">pcolor</span><span class="p">,</span> <span class="n">gca</span><span class="p">,</span> <span class="n">meshgrid</span><span class="p">,</span> <span class="n">xlabel</span><span class="p">,</span> <span class="n">ylabel</span><span class="p">,</span> <span class="n">xlim</span><span class="p">,</span> <span class="n">ylim</span><span class="p">,</span> <span class="n">colorbar</span><span class="p">,</span> <span class="n">savefig</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">resids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">selections</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">resids</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="n">pcolor</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qavg</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>

        <span class="n">xlim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">ylim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

        <span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;residues&quot;</span><span class="p">)</span>
        <span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;residues&quot;</span><span class="p">)</span>

        <span class="n">colorbar</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

<div class="viewcode-block" id="ContactAnalysis1.plot_qavg"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis1.plot_qavg">[docs]</a>    <span class="k">def</span> <span class="nf">plot_qavg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot :attr:`ContactAnalysis1.qavg`, the matrix of average native contacts.</span>

<span class="sd">        .. function:: ContactAnalysis1.plot_qavg([filename, ...])</span>

<span class="sd">        If *filename* is supplied then the figure is also written to file (the</span>
<span class="sd">        suffix determines the file type, e.g. pdf, png, eps, ...). All other</span>
<span class="sd">        keyword arguments are passed on to :func:`pylab.imshow`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="n">imshow</span><span class="p">,</span> <span class="n">xlabel</span><span class="p">,</span> <span class="n">ylabel</span><span class="p">,</span> <span class="n">xlim</span><span class="p">,</span> <span class="n">ylim</span><span class="p">,</span> <span class="n">colorbar</span><span class="p">,</span> <span class="n">cm</span><span class="p">,</span> <span class="n">clf</span><span class="p">,</span> <span class="n">savefig</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">resids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">selections</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">resids</span>

        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;origin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;lower&#39;</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;aspect&#39;</span><span class="p">,</span> <span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;interpolation&#39;</span><span class="p">,</span> <span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;vmin&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;vmax&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;cmap&#39;</span><span class="p">,</span> <span class="n">cm</span><span class="o">.</span><span class="n">hot</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;extent&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>

        <span class="n">clf</span><span class="p">()</span>
        <span class="n">imshow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qavg</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">xlim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">ylim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

        <span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;residue from {0!r}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection_strings</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;residue from {0!r}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection_strings</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="n">colorbar</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span></div></div>


<span class="k">def</span> <span class="nf">best_hummer_q</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">lambda_constant</span><span class="o">=</span><span class="mf">1.8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the Best-Hummer fraction of native contacts (Q)</span>

<span class="sd">    A soft-cutoff contacts analysis</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r: array</span>
<span class="sd">      Contact distances at time t</span>
<span class="sd">    r0: array</span>
<span class="sd">      Contact distances at time t=0, reference distances</span>
<span class="sd">    beta: float (default 5.0 Angstrom)</span>
<span class="sd">      Softness of the switching function</span>
<span class="sd">    lambda_constant: float (default 1.8, unitless)</span>
<span class="sd">      Reference distance tolerance</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Q : float</span>
<span class="sd">      Fraction of native contacts</span>
<span class="sd">    result : array</span>
<span class="sd">      Intermediate, r-r0 array transformed by the switching function</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">beta</span><span class="o">*</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">lambda_constant</span> <span class="o">*</span> <span class="n">r0</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">r0</span><span class="p">),</span> <span class="n">result</span>


<div class="viewcode-block" id="Contacts"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.Contacts">[docs]</a><span class="k">class</span> <span class="nc">Contacts</span><span class="p">(</span><span class="n">AnalysisBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate fraction of native contacts (Q) from a trajectory</span>

<span class="sd">    Inputs</span>
<span class="sd">    ------</span>
<span class="sd">    Two string selections for the contacting AtomGroups,</span>
<span class="sd">    the groups could be protein-lipid or protein-protein.</span>

<span class="sd">    Use two reference AtomGroups to obtain reference distances (r0)</span>
<span class="sd">    for the cotacts.</span>

<span class="sd">    Methods available</span>
<span class="sd">    -----------------</span>
<span class="sd">    Supports either hard-cutoff or soft-cutoff (Best-Hummer like [1]_)</span>
<span class="sd">    contacts.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        Returns a list of following structure::</span>
<span class="sd">            {</span>
<span class="sd">                [[t1, q1], [t2, q2], ... [tn, qn]]</span>
<span class="sd">            }</span>
<span class="sd">        where t is time in ps and q is the fraction of native contacts</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    1. Protein folding::</span>

<span class="sd">        ref = Universe(&quot;villin.gro&quot;)</span>
<span class="sd">        u = Universe(&quot;conf_protein.gro&quot;, &quot;traj_protein.xtc&quot;)</span>
<span class="sd">        Q = calculate_contacts(u, ref, &quot;protein and not name H*&quot;, &quot;protein and not name H*&quot;)</span>

<span class="sd">    2. A pair of helices::</span>

<span class="sd">        ref = Universe(&quot;glycophorin_dimer.pdb&quot;)</span>
<span class="sd">        u = Universe(&quot;conf_protein.gro&quot;, &quot;traj_protein.xtc&quot;)</span>
<span class="sd">        Q = calculate_contacts(u, ref, \</span>
<span class="sd">            &quot;protein and resid 75-92 and not name H* and segid A&quot;, \</span>
<span class="sd">            &quot;protein and resid 75-92 and not name H* and segid B&quot;)</span>

<span class="sd">    Parameter choices</span>
<span class="sd">    -----------------</span>
<span class="sd">    There are recommendations and not strict orders.</span>
<span class="sd">    These parameters should be insensitive to small changes.</span>
<span class="sd">    * For all-atom simulations, radius = 4.5 A and lambda_constant = 1.8 (unitless)</span>
<span class="sd">    * For coarse-grained simulations, radius = 6.0 A and lambda_constant = 1.5 (unitless)</span>

<span class="sd">    Additional</span>
<span class="sd">    ----------</span>
<span class="sd">    Supports writing and reading the analysis results to and from a text file.</span>
<span class="sd">    Supports simple plotting operations, for exploratory data analysis.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    We use the definition of Best et al [1]_, namely Eq. (1) of the SI</span>
<span class="sd">    defines the expression for the fraction of native contacts,</span>
<span class="sd">    $Q(X)$:</span>

<span class="sd">    .. math::</span>

<span class="sd">        Q(X) = \frac{1}{|S|} \sum_{(i,j) \in S}</span>
<span class="sd">               \frac{1}{1 + \exp[\beta(r_{ij}(X) - \lambda r_{ij}^0)]}</span>

<span class="sd">    where:</span>

<span class="sd">    * :math:`X` is a conformation,</span>
<span class="sd">    * :math:`r_{ij}(X)` is the distance between atoms $i$ and $j$ in</span>
<span class="sd">      conformation $X$,</span>
<span class="sd">    * :math:`r^0_{ij}` is the distance from heavy atom i to j in the</span>
<span class="sd">      native state conformation,</span>
<span class="sd">    * :math:`S` is the set of all pairs of heavy atoms $(i,j)$</span>
<span class="sd">      belonging to residues $\theta_i$ and $\theta_j$ such that</span>
<span class="sd">      $|\theta_i - \theta_j| &gt; 3$ and $r^0_{i,} &lt; 4.5</span>
<span class="sd">      \unicode{x212B}$,</span>
<span class="sd">    * :math:`\beta=5 \unicode{x212B}^{-1},</span>
<span class="sd">    * :math:`\lambda=1.8` for all-atom simulations</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    .. [1] RB Best, G Hummer, and WA Eaton, &quot;Native contacts determine</span>
<span class="sd">       protein folding mechanisms in atomistic simulations&quot; _PNAS_</span>
<span class="sd">       **110** (2013), 1787417879.  `10.1073/pnas.1311599110</span>
<span class="sd">       &lt;http://doi.org/10.1073/pnas.1311599110&gt;`_.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">selection</span><span class="p">,</span> <span class="n">refgroup</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;cutoff&quot;</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">4.5</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">start</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the persistence length for polymer chains</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u: Universe</span>
<span class="sd">            trajectory</span>
<span class="sd">        selection: tuple(string, string)</span>
<span class="sd">            two contacting groups that change over time</span>
<span class="sd">        refgroup: tuple(AtomGroup, AtomGroup)</span>
<span class="sd">            two contacting groups in their reference conformation</span>
<span class="sd">        radius: float, optional (4.5 Angstroms)</span>
<span class="sd">            radius within which contacts exist</span>
<span class="sd">        method: string</span>
<span class="sd">            either &#39;cutoff&#39; or &#39;best-hummer&#39;</span>

<span class="sd">        start : int, optional</span>
<span class="sd">            First frame of trajectory to analyse, Default: 0</span>
<span class="sd">        stop : int, optional</span>
<span class="sd">            Last frame of trajectory to analyse, Default: -1</span>
<span class="sd">        step : int, optional</span>
<span class="sd">            Step between frames to analyse, Default: 1</span>

<span class="sd">        Parameters for &#39;best-hummer&#39; method</span>
<span class="sd">        -----------------------------------</span>
<span class="sd">        lambda_constant: float, optional (1.8 unitless)</span>
<span class="sd">            contact is considered formed between (lambda*r0,r0)</span>
<span class="sd">        beta: float, optional (5 Angstroms^-1)</span>
<span class="sd">            softness of the switching function, the lower the softer</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        results: list</span>
<span class="sd">            Fraction of native contacts for each frame</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check method</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;cutoff&quot;</span><span class="p">,</span> <span class="s2">&quot;best-hummer&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;method has to be &#39;cutoff&#39; or &#39;best-hummer&#39;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_method</span> <span class="o">=</span> <span class="n">method</span>

        <span class="c1"># method-specific parameters</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;best-hummer&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;beta&#39;</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lambda_constant</span>  <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;lambda_constant&#39;</span><span class="p">,</span> <span class="mf">1.8</span><span class="p">)</span>

        <span class="c1"># steup boilerplate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">u</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_frames</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">,</span>
                           <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
                           <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span>
                           <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="n">selection</span>
        <span class="n">grA</span><span class="p">,</span> <span class="n">grB</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">selection</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">selection</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grA</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grB</span> <span class="o">=</span> <span class="n">grA</span><span class="p">,</span> <span class="n">grB</span>
        <span class="n">refA</span><span class="p">,</span> <span class="n">refB</span> <span class="o">=</span> <span class="n">refgroup</span>

        <span class="c1"># contacts formed in reference</span>
        <span class="n">r0</span> <span class="o">=</span> <span class="n">distance_array</span><span class="p">(</span><span class="n">refA</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="n">refB</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r0</span> <span class="o">=</span> <span class="n">r0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">r0</span> <span class="o">&lt;</span> <span class="n">radius</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">contact_matrix</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outfile</span> <span class="o">=</span> <span class="n">outfile</span>

<div class="viewcode-block" id="Contacts.load"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.Contacts.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load the data file.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        filename : string</span>
<span class="sd">            name of the data file to be read (can be compressed</span>
<span class="sd">            or a stream, see :func:`~MDAnalysis.lib.util.openany`</span>
<span class="sd">            for what is possible)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">records</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">openany</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">):</span> <span class="k">continue</span>
                <span class="n">records</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">records</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_single_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">grA</span><span class="p">,</span> <span class="n">grB</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grA</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grB</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">r0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span>

        <span class="c1"># compute distance array for a frame</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">distance_array</span><span class="p">(</span><span class="n">grA</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="n">grB</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span>

        <span class="c1"># select only the contacts that were formed in the reference state</span>
        <span class="c1"># r, r0 are 1D array</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">r0</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">r0</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_method</span> <span class="o">==</span> <span class="s2">&quot;cutoff&quot;</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">r0</span>
            <span class="n">y</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span><span class="o">/</span><span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_method</span> <span class="o">==</span> <span class="s2">&quot;best-hummer&quot;</span><span class="p">:</span>
            <span class="n">y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">best_hummer_q</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambda_constant</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown method type, has to be &#39;cutoff&#39; or &#39;best-hummer&#39;&quot;</span><span class="p">)</span>

        <span class="n">cm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">grA</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">grB</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">cm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contact_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cm</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_ts</span><span class="o">.</span><span class="n">frame</span> <span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">_conclude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Finalise the timeseries you&#39;ve gathered.</span>

<span class="sd">        Called at the end of the run() method to finish everything up.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># write output</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">outfile</span><span class="p">:</span> <span class="k">return</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outfile</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;# q1 analysis</span><span class="se">\n</span><span class="s2"># nref = {0:d}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;# frame  q1  n1</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">frame</span><span class="p">,</span> <span class="n">q1</span><span class="p">,</span> <span class="n">n1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;{frame:4d}  {q1:8.6f} {n1:5d}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="nb">vars</span><span class="p">()))</span>

<div class="viewcode-block" id="Contacts.contact_matrix"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.Contacts.contact_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">contact_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return distance array with True for contacts.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        d : array</span>
<span class="sd">            is the matrix of distances. The method uses the value of</span>
<span class="sd">            `ContactAnalysis1.radius` to determine if a ``distance &lt; radius``</span>
<span class="sd">            is considered a contact.</span>
<span class="sd">        out: array (optional)</span>
<span class="sd">            If `out` is supplied as a pre-allocated array of the correct</span>
<span class="sd">            shape then it is filled instead of allocating a new one in</span>
<span class="sd">            order to increase performance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array</span>
<span class="sd">            boolean array of which contacts are formed</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This method is typically only used internally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="Contacts.fraction_native"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.Contacts.fraction_native">[docs]</a>    <span class="k">def</span> <span class="nf">fraction_native</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate native contacts relative to reference state.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q: array</span>
<span class="sd">            is the matrix of contacts (e.g. `ContactAnalysis1.q`).</span>
<span class="sd">        out: array</span>
<span class="sd">            If *out* is supplied as a pre-allocated array of the correct</span>
<span class="sd">            shape then it is filled instead of allocating a new one in</span>
<span class="sd">            order to increase performance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        contacts : integer</span>
<span class="sd">           total number of contacts</span>
<span class="sd">        fraction : float</span>
<span class="sd">           Fraction of native contacts (Q) calculated from a contact matrix</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This method is typically only used internally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">contacts</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">contacts</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">contacts</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span></div>

<div class="viewcode-block" id="Contacts.plot"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.Contacts.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot q(t).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            If `filename` is supplied then the figure is also written to file (the</span>
<span class="sd">            suffix determines the file type, e.g. pdf, png, eps, ...). All other</span>
<span class="sd">            keyword arguments are passed on to `pylab.plot`.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Arbitrary keyword arguments for the plotting function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No timeseries data; do &#39;Contacts.run()&#39; first.&quot;</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span><span class="p">)</span>

        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;black&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;linewidth&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">r&quot;frame number $t$&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">r&quot;contacts $q_1$&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">filename</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

<div class="viewcode-block" id="Contacts.plot_qavg"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.Contacts.plot_qavg">[docs]</a>    <span class="k">def</span> <span class="nf">plot_qavg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot `Contacts.qavg`, the matrix of average contacts.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            If `filename` is supplied then the figure is also written to file (the</span>
<span class="sd">            suffix determines the file type, e.g. pdf, png, eps, ...). All other</span>
<span class="sd">            keyword arguments are passed on to `pylab.imshow`.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Arbitrary keyword arguments for the plotting function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">contact_matrix</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No timeseries data; do &#39;Contacts.run()&#39; first.&quot;</span><span class="p">)</span>
        <span class="c1"># collapse on the time-axis</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contact_matrix</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
        <span class="kn">import</span> <span class="nn">matplotlib.cm</span> <span class="kn">as</span> <span class="nn">cm</span>

        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;origin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;lower&#39;</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;aspect&#39;</span><span class="p">,</span> <span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;interpolation&#39;</span><span class="p">,</span> <span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;vmin&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;vmax&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;cmap&#39;</span><span class="p">,</span> <span class="n">cm</span><span class="o">.</span><span class="n">hot</span><span class="p">)</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="n">cax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">cbar</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cax</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">filename</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.14.1-dev0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2005-2015, Naveen Michaud-Agrawal, Elizabeth J. Denning, Christian Beckstein (logo), Joshua L. Adelman, Balasubramanian, Jonathan Barnoud, Alejandro Bernardin, Sbastien Buchoux, David Caplan, Matthieu Chavent, John Detlefs, Xavier Deupi, Jan Domanski, David L. Dotson, Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar, Abhinav Gupta, Benjamin Hall, Kyle J. Huston, Joe Jordan, Max Linke, Jinju Lu, Robert McGibbon, Manuel Nuno Melo, Alex Nesterenko, Hai Nguyen, Mattia F. Palermo, Danny Parton, Joshua L. Phillips, Tyler Reddy, Paul Rigor, Carlos Yanez S., Utkarsh Saxena, Sean L. Seyler, Andy Somogyi, Caio S. Souza, Lukas Stelzl, Gorman Stock, Isaac Virshup, Zhuyi Xue, and Oliver Beckstein.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.5.
    </div>
  </body>
</html>