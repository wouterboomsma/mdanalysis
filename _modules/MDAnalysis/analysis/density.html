<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MDAnalysis.analysis.density &mdash; MDAnalysis 0.14.1-dev0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.14.1-dev0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.14.1-dev0 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="top" title="MDAnalysis 0.14.1-dev0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.14.1-dev0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/mdanalysis-logo-200x150.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for MDAnalysis.analysis.density</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c1"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4</span>
<span class="c1">#</span>
<span class="c1"># MDAnalysis --- http://www.MDAnalysis.org</span>
<span class="c1"># Copyright (c) 2006-2015 Naveen Michaud-Agrawal, Elizabeth J. Denning, Oliver Beckstein</span>
<span class="c1"># and contributors (see AUTHORS for the full list)</span>
<span class="c1">#</span>
<span class="c1"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c1">#</span>
<span class="c1"># Please cite your use of MDAnalysis in published work:</span>
<span class="c1">#</span>
<span class="c1"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c1"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c1">#</span>

<span class="c1"># MDAnalysis -- density analysis</span>
<span class="c1"># Copyright (c) 2007-2011 Oliver Beckstein &lt;orbeckst@gmail.com&gt;</span>
<span class="c1"># (based on code from Hop --- a framework to analyze solvation dynamics from MD simulations)</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Generating densities from trajectories --- :mod:`MDAnalysis.analysis.density`</span>
<span class="sd">=============================================================================</span>

<span class="sd">:Author: Oliver Beckstein</span>
<span class="sd">:Year: 2011</span>
<span class="sd">:Copyright: GNU Public License v3</span>

<span class="sd">The module provides classes and functions to generate and represent</span>
<span class="sd">volumetric data, in particular densities.</span>

<span class="sd">Generating a density from a MD trajectory</span>
<span class="sd">-----------------------------------------</span>

<span class="sd">An input trajectory is required that</span>

<span class="sd">1. Has been centered on the protein of interest.</span>
<span class="sd">2. Has all molecules made whole that have been broken across periodic</span>
<span class="sd">   boundaries.</span>
<span class="sd">3. Has the solvent molecules remapped so that they are closest to the</span>
<span class="sd">   solute (this is important when using funky unit cells such as</span>
<span class="sd">   a dodecahedron or a truncated octahedron).</span>

<span class="sd">To generate the density of water molecules around a protein::</span>

<span class="sd">  from MDAnalysis.analysis.density import density_from_Universe</span>
<span class="sd">  u = Universe(PSF,DCD)</span>
<span class="sd">  D = density_from_Universe(u, delta=1.0, atomselection=&quot;name OH2&quot;)</span>
<span class="sd">  D.convert_density(&#39;TIP3P&#39;)</span>
<span class="sd">  D.export(&quot;water.dx&quot;)</span>

<span class="sd">The positions of all water oxygens are histogrammed on a grid with spacing</span>
<span class="sd">*delta* = 1 A. Initially the density is measured in 1/A**3. With the</span>
<span class="sd">:meth:`Density.convert_density` method, the units of measurement are</span>
<span class="sd">changed. In the example we are now measuring the density relative to the</span>
<span class="sd">literature value of the TIP3P water model at ambient conditions (see the values</span>
<span class="sd">in :data:`MDAnalysis.units.water` for details). Finally, the density is</span>
<span class="sd">writte as an OpenDX_ compatible file that can be read in VMD_ or PyMOL_.</span>

<span class="sd">See :class:`Density` for details. In particular, the density is stored</span>
<span class="sd">as a NumPy array in :attr:`Density.grid`, which can be processed in</span>
<span class="sd">any manner.</span>

<span class="sd">.. _OpenDX: http://www.opendx.org/</span>


<span class="sd">Classes and Functions</span>
<span class="sd">---------------------</span>

<span class="sd">.. autoclass:: Density</span>
<span class="sd">   :members:</span>
<span class="sd">   :inherited-members:</span>
<span class="sd">   :show-inheritance:</span>
<span class="sd">.. autofunction:: density_from_Universe</span>
<span class="sd">.. autofunction:: density_from_PDB</span>
<span class="sd">.. autofunction:: Bfactor2RMSF</span>
<span class="sd">.. autoclass:: BfactorDensityCreator</span>
<span class="sd">   :members:</span>
<span class="sd">.. autoclass:: Grid</span>
<span class="sd">   :members:</span>
<span class="sd">   :inherited-members:</span>

<span class="sd">.. deprecated:: 0.15.0</span>
<span class="sd">    The &quot;permissive&quot; flag is not used anymore (and effectively</span>
<span class="sd">    defaults to True); it will be completely removed in 0.16.0.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="kn">import</span> <span class="nb">range</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">errno</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">gridData</span> <span class="kn">import</span> <span class="n">Grid</span>  <span class="c1"># http://github.com/orbeckst/GridDataFormats</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
        <span class="sd">&quot;&quot;&quot;ERROR --- The GridDataFormats package can not be found!</span>

<span class="sd">        The &#39;gridData&#39; module from GridDataFormats could not be</span>
<span class="sd">        imported. Please install it first.  You can try installing with</span>
<span class="sd">        setuptools directly from the internet:</span>

<span class="sd">          easy_install GridDataFormats</span>

<span class="sd">        Alternatively, download the package from</span>

<span class="sd">          http://pypi.python.org/pypi/GridDataFormats/</span>

<span class="sd">        and install in the usual manner.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="p">)</span>

<span class="kn">import</span> <span class="nn">MDAnalysis</span>
<span class="kn">import</span> <span class="nn">MDAnalysis.core.AtomGroup</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib.util</span> <span class="kn">import</span> <span class="n">fixedwidth_bins</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">asiterable</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib</span> <span class="kn">import</span> <span class="n">NeighborSearch</span> <span class="k">as</span> <span class="n">NS</span>
<span class="kn">from</span> <span class="nn">MDAnalysis</span> <span class="kn">import</span> <span class="n">NoDataError</span><span class="p">,</span> <span class="n">MissingDataWarning</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">units</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib.log</span> <span class="kn">import</span> <span class="n">ProgressMeter</span>

<span class="kn">import</span> <span class="nn">MDAnalysis.analysis.distances</span>

<span class="kn">import</span> <span class="nn">logging</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;MDAnalysis.analysis.density&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="Density"><a class="viewcode-back" href="../../../documentation_pages/analysis/density.html#MDAnalysis.analysis.density.Density">[docs]</a><span class="k">class</span> <span class="nc">Density</span><span class="p">(</span><span class="n">Grid</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class representing a density on a regular cartesian grid.</span>

<span class="sd">    The data (:attr:`Density.grid`) can be manipulated as a standard numpy</span>
<span class="sd">    array. Changes can be saved to a file using the :meth:`Density.save` method. The</span>
<span class="sd">    grid can be restored using the :meth:`Density.load` method or by supplying the</span>
<span class="sd">    filename to the constructor.</span>

<span class="sd">    The attribute :attr:`Density.metadata` holds a user-defined dictionary that</span>
<span class="sd">    can be used to annotate the data. It is also saved with :meth:`Density.save`.</span>

<span class="sd">    The :meth:`Density.export` method always exports a 3D object</span>
<span class="sd">    (written in such a way to be readable in VMD_ and PyMOL_), the</span>
<span class="sd">    rest should work for an array of any dimension.</span>

<span class="sd">    If the input histogram consists of counts per cell then the</span>
<span class="sd">    :meth:`Density.make_density` method converts the grid to a physical density. For</span>
<span class="sd">    a probability density, divide it by :meth:`Density.grid.sum` or use ``normed=True``</span>
<span class="sd">    right away in :func:`~numpy.histogramdd`.</span>

<span class="sd">    The user *should* set the *parameters* keyword (see docs for the</span>
<span class="sd">    constructor); in particular, if the data are already a density, one must</span>
<span class="sd">    set *isDensity* == ``True`` because there is no reliable way to detect if</span>
<span class="sd">    data represent counts or a density. As a special convenience, if data are</span>
<span class="sd">    read from a file and the user has not set *isDensity* then it is assumed</span>
<span class="sd">    that the data are in fact a density.</span>

<span class="sd">    Typical use:</span>

<span class="sd">    1. From a histogram (i.e. counts on a grid)::</span>

<span class="sd">        h,edges = numpy.histogramdd(...)</span>
<span class="sd">        D = Density(h, edges, parameters={&#39;isDensity&#39;: False}, units={&#39;length&#39;: &#39;A&#39;})</span>
<span class="sd">        D.make_density()</span>

<span class="sd">    2. From a saved density file (e.g. in OpenDX format), where the lengths are</span>
<span class="sd">       in Angstrom and the density in 1/A**3::</span>

<span class="sd">         D = Density(&quot;density.dx&quot;)</span>

<span class="sd">    3. From a saved density file (e.g. in OpenDX format), where the lengths are</span>
<span class="sd">       in Angstrom and the density is measured relative to the density of water</span>
<span class="sd">       at ambient conditions::</span>

<span class="sd">         D = Density(&quot;density.dx&quot;, units={&#39;density&#39;: &#39;water&#39;})</span>

<span class="sd">    4. From a saved *histogram* (less common, but in order to demonstrate the</span>
<span class="sd">       *parameters* keyword) where the lengths are in nm::</span>

<span class="sd">         D = Density(&quot;counts.dx&quot;, parameters={&#39;isDensity&#39;: False}, units={&#39;length&#39;: &#39;nm&#39;})</span>
<span class="sd">         D.make_density()</span>
<span class="sd">         D.convert_length(&#39;Angstrom^{-3}&#39;)</span>
<span class="sd">         D.convert_density(&#39;water&#39;)</span>

<span class="sd">       After the final step, ``D`` will contain a density on a grid measured in</span>
<span class="sd">       Angstrom, with the density values itself measured relative to the</span>
<span class="sd">       density of water.</span>

<span class="sd">    :class:`Density` objects can be algebraically manipulated (added,</span>
<span class="sd">    subtracted, multiplied, ...)  but there are *no sanity checks* in place to</span>
<span class="sd">    make sure that units, metadata, etc are compatible!</span>

<span class="sd">    .. Note::</span>

<span class="sd">       It is suggested to construct the Grid object from a histogram,</span>
<span class="sd">       to supply the appropriate length unit, and to use</span>
<span class="sd">       :meth:`Density.make_density` to obtain a density. This ensures</span>
<span class="sd">       that the length- and the density unit correspond to each other.</span>

<span class="sd">    .. SeeAlso::</span>

<span class="sd">       :class:`Grid` which is the base class of</span>
<span class="sd">       :class:`Density`. (:class:`Grid` has been imported from</span>
<span class="sd">       :class:`gridData.Grid` which is part of GridDataFormats_).</span>

<span class="sd">    .. _VMD:   http://www.ks.uiuc.edu/Research/vmd/</span>
<span class="sd">    .. _PyMOL: http://www.pymol.org/</span>
<span class="sd">    .. _GridDataFormats: https://github.com/orbeckst/GridDataFormats</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a :class:`Density` from data.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">          *grid*</span>
<span class="sd">            histogram or density, typically a :class:`numpy.ndarray`</span>
<span class="sd">          *edges*</span>
<span class="sd">            list of arrays, the lower and upper bin edges along the axes</span>
<span class="sd">          *parameters*</span>
<span class="sd">            dictionary of class parameters; saved with</span>
<span class="sd">            :meth:`Density.save`. The following keys are meaningful to</span>
<span class="sd">            the class. Meaning of the values are listed:</span>

<span class="sd">             *isDensity*</span>

<span class="sd">                - ``False``: grid is a histogram with counts [default]</span>
<span class="sd">                - ``True``: a density</span>

<span class="sd">                Applying :meth:`Density.make_density`` sets it to ``True``.</span>
<span class="sd">          *units*</span>
<span class="sd">            A dict with the keys</span>

<span class="sd">            - *length*:  physical unit of grid edges (Angstrom or nm) [Angstrom]</span>
<span class="sd">            - *density*: unit of the density if ``isDensity == True`` or ``None``</span>
<span class="sd">              otherwise; the default is &quot;Angstrom^{-3}&quot; for densities (meaning A^-3).</span>

<span class="sd">            (Actually, the default unit is the value of</span>
<span class="sd">            :attr:`MDAnalysis.core.flags[&#39;length_unit&#39;]`; in most cases this is &quot;Angstrom&quot;.)</span>

<span class="sd">          *metadata*</span>
<span class="sd">            a user defined dictionary of arbitrary values associated with the</span>
<span class="sd">            density; the class does not touch :attr:`Density.metadata` but</span>
<span class="sd">            stores it with :meth:`Density.save`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">length_unit</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;length_unit&#39;</span><span class="p">]</span>

        <span class="n">parameters</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;parameters&#39;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;grid&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="c1"># try to be smart: when reading from a file then it is likely that this</span>
            <span class="c1"># is a density</span>
            <span class="n">parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;isDensity&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">parameters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;isDensity&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="n">units</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;units&#39;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">units</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;length&#39;</span><span class="p">,</span> <span class="n">length_unit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;isDensity&#39;</span><span class="p">]:</span>
            <span class="n">units</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;density&#39;</span><span class="p">,</span> <span class="n">length_unit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">units</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;density&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">Density</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">parameters</span>  <span class="c1"># isDensity: set by make_density()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">units</span>

    <span class="k">def</span> <span class="nf">_check_set_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check that all bindings ``{unit_type : value, ...}`` in the dict `u` are valid and set the object&#39;s units</span>
<span class="sd">        attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># all this unit crap should be a class...</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">unit_type</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">u</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>  <span class="c1"># check here, too iffy to use dictionary[None]=None</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="n">unit_type</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="k">continue</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">units</span><span class="o">.</span><span class="n">conversion_factor</span><span class="p">[</span><span class="n">unit_type</span><span class="p">][</span><span class="n">value</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="n">unit_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unit &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; of type &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">unit_type</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; is not recognized.&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="s1">&#39;&quot;unit&quot; must be a dictionary with keys &quot;length&quot; and &quot;density.&#39;</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">fatal</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
        <span class="c1"># need at least length and density (can be None)</span>
        <span class="k">if</span> <span class="s1">&#39;length&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;&quot;unit&quot; must contain a unit for &quot;length&quot;.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;density&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="s1">&#39;density&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

<div class="viewcode-block" id="Density.make_density"><a class="viewcode-back" href="../../../documentation_pages/analysis/density.html#MDAnalysis.analysis.density.Density.make_density">[docs]</a>    <span class="k">def</span> <span class="nf">make_density</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the grid (a histogram, counts in a cell) to a density (counts/volume).</span>

<span class="sd">          make_density()</span>

<span class="sd">        (1) This changes the grid irrevocably.</span>
<span class="sd">        (2) For a probability density, manually divide by grid.sum().</span>

<span class="sd">        If this is already a density, then a warning is issued and nothing is done.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make it a density by dividing by the volume of each grid cell</span>
        <span class="c1"># (from numpy.histogramdd, which is for general n-D grids)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;isDensity&#39;</span><span class="p">]:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Running make_density() makes no sense: Grid is already a density. Nothing done.&quot;</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">dedges</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">]</span>
        <span class="n">D</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
            <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dedges</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">/=</span> <span class="n">dedges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;isDensity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="s1">&#39;density&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;^{-3}&quot;</span>  <span class="c1"># see units.densityUnit_factor</span></div>

<div class="viewcode-block" id="Density.convert_length"><a class="viewcode-back" href="../../../documentation_pages/analysis/density.html#MDAnalysis.analysis.density.Density.convert_length">[docs]</a>    <span class="k">def</span> <span class="nf">convert_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;Angstrom&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert Grid object to the new *unit*.</span>

<span class="sd">          Grid.convert_length(&lt;unit&gt;)</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *unit*</span>
<span class="sd">              Angstrom, nm</span>

<span class="sd">        This changes the edges but will not change the density; it is</span>
<span class="sd">        the user&#39;s responsibility to supply the appropriate unit if</span>
<span class="sd">        the Grid object is constructed from a density. It is suggested</span>
<span class="sd">        to start from a histogram and a length unit and use</span>
<span class="sd">        :meth:`make_density`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">]:</span>
            <span class="k">return</span>
        <span class="n">cvnfact</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">get_conversion_factor</span><span class="p">(</span><span class="s1">&#39;length&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">],</span> <span class="n">unit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">cvnfact</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">()</span>  <span class="c1"># needed to recalculate midpoints and origin</span></div>

<div class="viewcode-block" id="Density.convert_density"><a class="viewcode-back" href="../../../documentation_pages/analysis/density.html#MDAnalysis.analysis.density.Density.convert_density">[docs]</a>    <span class="k">def</span> <span class="nf">convert_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;Angstrom&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the density to the physical units given by *unit*.</span>

<span class="sd">          Grid.convert_to(unit)</span>

<span class="sd">        *unit* can be one of the following:</span>

<span class="sd">        =============  ===============================================================</span>
<span class="sd">        name           description of the unit</span>
<span class="sd">        =============  ===============================================================</span>
<span class="sd">        Angstrom^{-3}  particles/A**3</span>
<span class="sd">        nm^{-3}        particles/nm**3</span>
<span class="sd">        SPC            density of SPC water at standard conditions</span>
<span class="sd">        TIP3P          ... see :data:`MDAnalysis.units.water`</span>
<span class="sd">        TIP4P          ... see :data:`MDAnalysis.units.water`</span>
<span class="sd">        water          density of real water at standard conditions (0.997 g/cm**3)</span>
<span class="sd">        Molar          mol/l</span>
<span class="sd">        =============  ===============================================================</span>

<span class="sd">        Note:</span>

<span class="sd">          (1) This only works if the initial length unit is provided.</span>
<span class="sd">          (2) Conversions always go back to unity so there can be rounding</span>
<span class="sd">              and floating point artifacts for multiple conversions.</span>

<span class="sd">        There may be some undesirable cross-interactions with :meth:`convert_length`...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;isDensity&#39;</span><span class="p">]:</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="s1">&#39;The grid is not a density so converty_density() makes no sense.&#39;</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">fatal</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="s1">&#39;density&#39;</span><span class="p">]:</span>
            <span class="k">return</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">*=</span> <span class="n">units</span><span class="o">.</span><span class="n">get_conversion_factor</span><span class="p">(</span><span class="s1">&#39;density&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="s1">&#39;density&#39;</span><span class="p">],</span> <span class="n">unit</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The name of the unit ({0!r} supplied) must be one of:</span><span class="se">\n</span><span class="s2">{1!r}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">conversion_factor</span><span class="p">[</span><span class="s1">&#39;density&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="s1">&#39;density&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unit</span></div>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;isDensity&#39;</span><span class="p">]:</span>
            <span class="n">grid_type</span> <span class="o">=</span> <span class="s1">&#39;density&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grid_type</span> <span class="o">=</span> <span class="s1">&#39;histogram&#39;</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;Density &#39;</span> <span class="o">+</span> <span class="n">grid_type</span> <span class="o">+</span> <span class="s1">&#39; with &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; bins&gt;&#39;</span></div>

<div class="viewcode-block" id="density_from_Universe"><a class="viewcode-back" href="../../../documentation_pages/analysis/density.html#MDAnalysis.analysis.density.density_from_Universe">[docs]</a><span class="k">def</span> <span class="nf">density_from_Universe</span><span class="p">(</span><span class="n">universe</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">atomselection</span><span class="o">=</span><span class="s1">&#39;name OH2&#39;</span><span class="p">,</span>
                          <span class="n">start</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                          <span class="n">metadata</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">soluteselection</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                          <span class="n">use_kdtree</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">update_selection</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                          <span class="n">quiet</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                          <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a density grid from a :class:`MDAnalysis.Universe` object.</span>

<span class="sd">    The trajectory is read, frame by frame, and the atoms selected with *atomselection* are</span>
<span class="sd">    histogrammed on a grid with spacing *delta*::</span>

<span class="sd">      density_from_Universe(universe, delta=1.0, atomselection=&#39;name OH2&#39;, ...) --&gt; density</span>

<span class="sd">    .. Note:: By default, the *atomselection* is static, i.e., atoms are only</span>
<span class="sd">              selected once at the beginning. If you want dynamically changing</span>
<span class="sd">              selections (such as &quot;name OW and around 4.0 (protein and not name</span>
<span class="sd">              H*)&quot;) then set ``update_selection=True``. For the special case of</span>
<span class="sd">              calculating a density of the &quot;bulk&quot; solvent away from a solute</span>
<span class="sd">              use the optimized selections with keywords *cutoff* and</span>
<span class="sd">              *soluteselection*.</span>

<span class="sd">    :Arguments:</span>
<span class="sd">      universe</span>
<span class="sd">            :class:`MDAnalysis.Universe` object with a trajectory</span>

<span class="sd">    :Keywords:</span>
<span class="sd">      atomselection</span>
<span class="sd">            selection string (MDAnalysis syntax) for the species to be analyzed</span>
<span class="sd">            [&quot;name OH2&quot;]</span>
<span class="sd">      delta</span>
<span class="sd">            bin size for the density grid in Angstroem (same in x,y,z) [1.0]</span>
<span class="sd">      start, stop, step</span>
<span class="sd">            Slice the trajectory as ``trajectory[start&quot;stop:step]``; default</span>
<span class="sd">            is to read the whole trajectory.</span>
<span class="sd">      metadata</span>
<span class="sd">            dictionary of additional data to be saved with the object</span>
<span class="sd">      padding</span>
<span class="sd">            increase histogram dimensions by padding (on top of initial box size)</span>
<span class="sd">            in Angstroem [2.0]</span>
<span class="sd">      soluteselection</span>
<span class="sd">            MDAnalysis selection for the solute, e.g. &quot;protein&quot; [``None``]</span>
<span class="sd">      cutoff</span>
<span class="sd">            With *cutoff*, select &quot;&lt;atomsel&gt; NOT WITHIN &lt;cutoff&gt; OF &lt;soluteselection&gt;&quot;</span>
<span class="sd">            (Special routines that are faster than the standard ``AROUND`` selection)</span>
<span class="sd">            [0]</span>
<span class="sd">      update_selection</span>
<span class="sd">            Should the selection of atoms be updated for every step? [``False``]</span>
<span class="sd">            - ``True``: atom selection is updated for each frame, can be slow</span>
<span class="sd">            - ``False``: atoms are only selected at the beginning</span>
<span class="sd">      quiet</span>
<span class="sd">            Print status update to the screen for every *interval* frame? [``False``]</span>
<span class="sd">            - ``True``: no status updates when a new frame is processed</span>
<span class="sd">            - ``False``: status update every frame (including number of atoms</span>
<span class="sd">              processed, which is interesting with ``update_selection=True``)</span>
<span class="sd">      interval</span>
<span class="sd">           Show status update every *interval* frame [1]</span>
<span class="sd">      parameters</span>
<span class="sd">            dict with some special parameters for :class:`Density` (see doc)</span>
<span class="sd">      kwargs</span>
<span class="sd">            metadata, parameters are modified and passed on to :class:`Density`</span>

<span class="sd">    :Returns: :class:`Density`</span>

<span class="sd">    .. versionchanged:: 0.13.0</span>
<span class="sd">       *update_selection* and *quite* keywords added</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
        <span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The universe must be a proper MDAnalysis.Universe instance.&quot;</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">universe</span>
    <span class="k">if</span> <span class="n">cutoff</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">soluteselection</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># special fast selection for &#39;&lt;atomsel&gt; not within &lt;cutoff&gt; of &lt;solutesel&gt;&#39;</span>
        <span class="n">notwithin_coordinates</span> <span class="o">=</span> <span class="n">notwithin_coordinates_factory</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">atomselection</span><span class="p">,</span> <span class="n">soluteselection</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span>
                                                              <span class="n">use_kdtree</span><span class="o">=</span><span class="n">use_kdtree</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">current_coordinates</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">notwithin_coordinates</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">group</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">atomselection</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">current_coordinates</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">group</span><span class="o">.</span><span class="n">positions</span>

    <span class="n">coord</span> <span class="o">=</span> <span class="n">current_coordinates</span><span class="p">()</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Selected {0:d} atoms out of {1:d} atoms ({2!s}) from {3:d} total.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">atomselection</span><span class="p">)),</span> <span class="n">atomselection</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">)))</span>

    <span class="c1"># mild warning; typically this is run on RMS-fitted trajectories and</span>
    <span class="c1"># so the box information is rather meaningless</span>
    <span class="n">box</span><span class="p">,</span> <span class="n">angles</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
    <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="mf">90.</span><span class="p">,</span> <span class="mf">90.</span><span class="p">,</span> <span class="mf">90.</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Non-orthorhombic unit-cell --- make sure that it has been remapped properly!&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1"># Make the box bigger to avoid as much as possible &#39;outlier&#39;. This</span>
    <span class="c1"># is important if the sites are defined at a high density: in this</span>
    <span class="c1"># case the bulk regions don&#39;t have to be close to 1 * n0 but can</span>
    <span class="c1"># be less. It&#39;s much more difficult to deal with outliers.  The</span>
    <span class="c1"># ideal solution would use images: implement &#39;looking across the</span>
    <span class="c1"># periodic boundaries&#39; but that gets complicate when the box</span>
    <span class="c1"># rotates due to RMS fitting.</span>
    <span class="n">smin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">padding</span>
    <span class="n">smax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">padding</span>

    <span class="n">BINS</span> <span class="o">=</span> <span class="n">fixedwidth_bins</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">smin</span><span class="p">,</span> <span class="n">smax</span><span class="p">)</span>
    <span class="n">arange</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">BINS</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">],</span> <span class="n">BINS</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">])</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="n">BINS</span><span class="p">[</span><span class="s1">&#39;Nbins&#39;</span><span class="p">]</span>

    <span class="c1"># create empty grid with the right dimensions (and get the edges)</span>
    <span class="n">grid</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">arange</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">grid</span> <span class="o">*=</span> <span class="mf">0.0</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">pm</span> <span class="o">=</span> <span class="n">ProgressMeter</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">n_frames</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="n">quiet</span><span class="p">,</span>
                       <span class="n">format</span><span class="o">=</span><span class="s2">&quot;Histogramming </span><span class="si">%(n_atoms)6d</span><span class="s2"> atoms in frame &quot;</span>
                       <span class="s2">&quot;</span><span class="si">%(step)5d</span><span class="s2">/</span><span class="si">%(numsteps)d</span><span class="s2">  [</span><span class="si">%(percentage)5.1f%%</span><span class="s2">]</span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">check_slice_indices</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">:</span><span class="n">step</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">update_selection</span><span class="p">:</span>
           <span class="n">group</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">atomselection</span><span class="p">)</span>
           <span class="n">coord</span><span class="o">=</span><span class="n">group</span><span class="o">.</span><span class="n">positions</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="n">coord</span> <span class="o">=</span> <span class="n">current_coordinates</span><span class="p">()</span>

        <span class="n">pm</span><span class="o">.</span><span class="n">echo</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">frame</span><span class="p">,</span> <span class="n">n_atoms</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">coord</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">h</span><span class="p">[:],</span> <span class="n">edges</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">arange</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">grid</span> <span class="o">+=</span> <span class="n">h</span>  <span class="c1"># accumulate average histogram</span>


    <span class="n">n_frames</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">))</span>
    <span class="n">grid</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_frames</span><span class="p">)</span>

    <span class="c1"># pick from kwargs</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;metadata&#39;</span><span class="p">,</span> <span class="p">{})</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;psf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">filename</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;dcd&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">filename</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;atomselection&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atomselection</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;n_frames&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_frames</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;totaltime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;dt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">dt</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;time_unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;time_unit&#39;</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;trajectory_skip&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">skip_timestep</span>  <span class="c1"># frames</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;trajectory_skip&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># seems to not be used..</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;trajectory_delta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">delta</span>  <span class="c1"># in native units</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;trajectory_delta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">cutoff</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">soluteselection</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;soluteselection&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">soluteselection</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;cutoff&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cutoff</span>  <span class="c1"># in Angstrom</span>

    <span class="n">parameters</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;parameters&#39;</span><span class="p">,</span> <span class="p">{})</span>
    <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;isDensity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># must override</span>

    <span class="c1"># all other kwargs are discarded</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">Density</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;length&#39;</span><span class="p">:</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;length_unit&#39;</span><span class="p">]},</span>
                <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">make_density</span><span class="p">()</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Density completed (initial density in Angstrom**-3)&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">g</span></div>


<span class="k">def</span> <span class="nf">notwithin_coordinates_factory</span><span class="p">(</span><span class="n">universe</span><span class="p">,</span> <span class="n">sel1</span><span class="p">,</span> <span class="n">sel2</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">not_within</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">use_kdtree</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate optimized selection for &#39;*sel1* not within *cutoff* of *sel2*&#39;</span>

<span class="sd">    Example usage::</span>
<span class="sd">      notwithin_coordinates = notwithin_coordinates_factory(universe, &#39;name OH2&#39;,&#39;protein and not name H*&#39;,3.5)</span>
<span class="sd">      ...</span>
<span class="sd">      coord = notwithin_coordinates()        # changes with time step</span>
<span class="sd">      coord = notwithin_coordinates(cutoff2) # can use different cut off</span>

<span class="sd">    :Keywords:</span>
<span class="sd">      *not_within*</span>
<span class="sd">         True: selection behaves as &#39;not within&#39; (As described above)</span>
<span class="sd">         False: selection is a &lt;sel1&gt; WITHIN &lt;cutoff&gt; OF &lt;sel2&gt;&#39;</span>
<span class="sd">      *use_kdtree*</span>
<span class="sd">         True: use fast kd-tree based selections (requires new MDAnalysis &gt;= 0.6)</span>
<span class="sd">         False: use distance matrix approach</span>

<span class="sd">    .. Note::</span>

<span class="sd">       * Periodic boundary conditions are *not* taken into account: the naive</span>
<span class="sd">         minimum image convention employed in the distance check is currently</span>
<span class="sd">         not being applied to remap the coordinates themselves, and hence it</span>
<span class="sd">         would lead to counts in the wrong region.</span>
<span class="sd">       * The selections are static and do not change with time steps.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Benchmark of FABP system (solvent 3400 OH2, protein 2100 atoms) on G4 powerbook, 500 frames</span>
    <span class="c1">#                    cpu/s    relative   speedup       use_kdtree</span>
    <span class="c1"># distance matrix    633        1          1           False</span>
    <span class="c1"># AROUND + kdtree    420        0.66       1.5         n/a (&#39;name OH2 around 4 protein&#39;)</span>
    <span class="c1"># manual + kdtree    182        0.29       3.5         True</span>
    <span class="n">solvent</span> <span class="o">=</span> <span class="n">universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">sel1</span><span class="p">)</span>
    <span class="n">protein</span> <span class="o">=</span> <span class="n">universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">sel2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">use_kdtree</span><span class="p">:</span>
        <span class="c1"># using faster hand-coded &#39;not within&#39; selection with kd-tree</span>
        <span class="n">set_solvent</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">solvent</span><span class="p">)</span>  <span class="c1"># need sets to do bulk = allsolvent - selection</span>
        <span class="k">if</span> <span class="n">not_within</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>  <span class="c1"># default</span>
            <span class="k">def</span> <span class="nf">notwithin_coordinates</span><span class="p">(</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">):</span>
                <span class="c1"># must update every time step</span>
                <span class="n">ns_w</span> <span class="o">=</span> <span class="n">NS</span><span class="o">.</span><span class="n">AtomNeighborSearch</span><span class="p">(</span><span class="n">solvent</span><span class="p">)</span>  <span class="c1"># build kd-tree on solvent (N_w &gt; N_protein)</span>
                <span class="n">solvation_shell</span> <span class="o">=</span> <span class="n">ns_w</span><span class="o">.</span><span class="n">search_list</span><span class="p">(</span><span class="n">protein</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>  <span class="c1"># solvent within CUTOFF of protein</span>
                <span class="n">group</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">AtomGroup</span><span class="o">.</span><span class="n">AtomGroup</span><span class="p">(</span><span class="n">set_solvent</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">solvation_shell</span><span class="p">))</span>  <span class="c1"># bulk</span>
                <span class="k">return</span> <span class="n">group</span><span class="o">.</span><span class="n">positions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">notwithin_coordinates</span><span class="p">(</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">):</span>
                <span class="c1"># acts as &#39;&lt;solvent&gt; WITHIN &lt;cutoff&gt; OF &lt;protein&gt;&#39;</span>
                <span class="c1"># must update every time step</span>
                <span class="n">ns_w</span> <span class="o">=</span> <span class="n">NS</span><span class="o">.</span><span class="n">AtomNeighborSearch</span><span class="p">(</span><span class="n">solvent</span><span class="p">)</span>  <span class="c1"># build kd-tree on solvent (N_w &gt; N_protein)</span>
                <span class="n">group</span> <span class="o">=</span> <span class="n">ns_w</span><span class="o">.</span><span class="n">search_list</span><span class="p">(</span><span class="n">protein</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>  <span class="c1"># solvent within CUTOFF of protein</span>
                <span class="k">return</span> <span class="n">group</span><span class="o">.</span><span class="n">positions</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># slower distance matrix based (calculate all with all distances first)</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">solvent</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">protein</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">box</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1"># as long as s_coor is not minimum-image remapped</span>
        <span class="k">if</span> <span class="n">not_within</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>  <span class="c1"># default</span>
            <span class="n">compare</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">greater</span>
            <span class="n">aggregatefunc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">compare</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">less_equal</span>
            <span class="n">aggregatefunc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span>

        <span class="k">def</span> <span class="nf">notwithin_coordinates</span><span class="p">(</span><span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">):</span>
            <span class="n">s_coor</span> <span class="o">=</span> <span class="n">solvent</span><span class="o">.</span><span class="n">positions</span>
            <span class="n">p_coor</span> <span class="o">=</span> <span class="n">protein</span><span class="o">.</span><span class="n">positions</span>
            <span class="c1"># Does water i satisfy d[i,j] &gt; r for ALL j?</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">distance_array</span><span class="p">(</span><span class="n">s_coor</span><span class="p">,</span> <span class="n">p_coor</span><span class="p">,</span> <span class="n">box</span><span class="o">=</span><span class="n">box</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="n">dist</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">s_coor</span><span class="p">[</span><span class="n">aggregatefunc</span><span class="p">(</span><span class="n">compare</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">notwithin_coordinates</span>


<div class="viewcode-block" id="Bfactor2RMSF"><a class="viewcode-back" href="../../../documentation_pages/analysis/density.html#MDAnalysis.analysis.density.Bfactor2RMSF">[docs]</a><span class="k">def</span> <span class="nf">Bfactor2RMSF</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Atomic root mean square fluctuation (in Angstrom) from the crystallographic B-factor</span>

<span class="sd">    RMSF and B-factor are related by [Willis1975]_</span>

<span class="sd">    .. math::</span>

<span class="sd">        B = \frac{8\pi^2}{3} \rm{RMSF}^2</span>

<span class="sd">    and this function returns</span>

<span class="sd">    .. math::</span>

<span class="sd">        \rm{RMSF} = \sqrt{\frac{3 B}{8\pi^2}}</span>

<span class="sd">    .. rubric:: References</span>

<span class="sd">    .. [Willis1975]  BTM Willis and AW Pryor. *Thermal vibrations in crystallography*. Cambridge Univ. Press, 1975</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.</span> <span class="o">*</span> <span class="n">B</span> <span class="o">/</span> <span class="mf">8.</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span></div>


<div class="viewcode-block" id="density_from_PDB"><a class="viewcode-back" href="../../../documentation_pages/analysis/density.html#MDAnalysis.analysis.density.density_from_PDB">[docs]</a><span class="k">def</span> <span class="nf">density_from_PDB</span><span class="p">(</span><span class="n">pdb</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a density from a single frame PDB.</span>

<span class="sd">    Typical use is to make a density from the crystal water</span>
<span class="sd">    molecules. The density is created from isotropic gaussians</span>
<span class="sd">    centered at each selected atoms. If B-factors are present in the</span>
<span class="sd">    file then they are used to calculate the width of the gaussian.</span>

<span class="sd">    Using the *sigma* keyword, one can override this choice and</span>
<span class="sd">    prescribe a gaussian width for all atoms (in Angstrom), which is</span>
<span class="sd">    calculated as described for :func:`Bfactor2RMSF`.</span>

<span class="sd">    .. Note::</span>

<span class="sd">       The current implementation is *painfully* slow.</span>

<span class="sd">    .. SeeAlso::</span>

<span class="sd">       :func:`Bfactor2RMSF` and :class:`BfactorDensityCreator`.</span>

<span class="sd">    :Arguments:</span>
<span class="sd">       *pdb*</span>
<span class="sd">          PDB file (should have the temperatureFactor set); ANISO</span>
<span class="sd">          records are currently *not* processed</span>

<span class="sd">    :Keywords:</span>
<span class="sd">       *atomselection*</span>
<span class="sd">          selection string (MDAnalysis syntax) for the species to be analyzed</span>
<span class="sd">          [&#39;resname HOH and name O&#39;]</span>
<span class="sd">       *delta*</span>
<span class="sd">          bin size for the density grid in Angstroem (same in x,y,z) [1.0]</span>
<span class="sd">       *metadata*</span>
<span class="sd">          dictionary of additional data to be saved with the object [``None``]</span>
<span class="sd">       *padding*</span>
<span class="sd">          increase histogram dimensions by padding (on top of initial box size) [1.0]</span>
<span class="sd">       *sigma*</span>
<span class="sd">          width (in Angstrom) of the gaussians that are used to build up the</span>
<span class="sd">          density; if ``None`` then uses B-factors from *pdb* [``None``]</span>

<span class="sd">    :Returns: a :class:`Density` object with a density measured relative to the</span>
<span class="sd">              water density at standard conditions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">BfactorDensityCreator</span><span class="p">(</span><span class="n">pdb</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">Density</span><span class="p">()</span></div>


<div class="viewcode-block" id="BfactorDensityCreator"><a class="viewcode-back" href="../../../documentation_pages/analysis/density.html#MDAnalysis.analysis.density.BfactorDensityCreator">[docs]</a><span class="k">class</span> <span class="nc">BfactorDensityCreator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a density grid from a pdb file using MDAnalysis.</span>

<span class="sd">      dens = BfactorDensityCreator(pdb,...).Density()</span>

<span class="sd">    The main purpose of this function is to convert crystal waters in</span>
<span class="sd">    an X-ray structure into a density so that one can compare the</span>
<span class="sd">    experimental density with the one from molecular dynamics</span>
<span class="sd">    trajectories. Because a pdb is a single snapshot, the density is</span>
<span class="sd">    estimated by placing Gaussians of width sigma at the position of</span>
<span class="sd">    all selected atoms.</span>

<span class="sd">    Sigma can be fixed or taken from the B-factor field, in which case</span>
<span class="sd">    sigma is taken as sqrt(3.*B/8.)/pi (see :func:`BFactor2RMSF`).</span>

<span class="sd">    .. TODO</span>
<span class="sd">    .. * Make Gaussian convolution more efficient (at least for same</span>
<span class="sd">    ..   sigma) because right now it is *very* slow (which may be</span>
<span class="sd">    ..   acceptable if one only runs this once)</span>
<span class="sd">    .. * Using a temporary Creator class with the</span>
<span class="sd">    ..   :meth:`BfactorDensityCreator.Density` helper method is clumsy.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdb</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">atomselection</span><span class="o">=</span><span class="s1">&#39;resname HOH and name O&#39;</span><span class="p">,</span>
                 <span class="n">metadata</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct the density from psf and pdb and the atomselection.</span>

<span class="sd">          DC = BfactorDensityCreator(pdb, delta=&lt;delta&gt;, atomselection=&lt;MDAnalysis selection&gt;,</span>
<span class="sd">                                  metadata=&lt;dict&gt;, padding=2, sigma=None)</span>

<span class="sd">          density = DC.Density()</span>

<span class="sd">        :Arguments:</span>

<span class="sd">          pdb</span>
<span class="sd">            PDB file or :class:`MDAnalysis.Universe`;</span>
<span class="sd">          atomselection</span>
<span class="sd">            selection string (MDAnalysis syntax) for the species to be analyzed</span>
<span class="sd">          delta</span>
<span class="sd">            bin size for the density grid in Angstroem (same in x,y,z) [1.0]</span>
<span class="sd">          metadata</span>
<span class="sd">            dictionary of additional data to be saved with the object</span>
<span class="sd">          padding</span>
<span class="sd">            increase histogram dimensions by padding (on top of initial box size)</span>
<span class="sd">          sigma</span>
<span class="sd">            width (in Angstrom) of the gaussians that are used to build up the</span>
<span class="sd">            density; if None then uses B-factors from pdb</span>

<span class="sd">        For assigning X-ray waters to MD densities one might have to use a sigma</span>
<span class="sd">        of about 0.5 A to obtain a well-defined and resolved x-ray water density</span>
<span class="sd">        that can be easily matched to a broader density distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">as_Universe</span><span class="p">(</span><span class="n">pdb</span><span class="p">)</span>
        <span class="n">group</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">atomselection</span><span class="p">)</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">positions</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Selected {0:d} atoms ({1!s}) out of {2:d} total.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">atomselection</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">)))</span>
        <span class="n">smin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">padding</span>
        <span class="n">smax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">padding</span>

        <span class="n">BINS</span> <span class="o">=</span> <span class="n">fixedwidth_bins</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">smin</span><span class="p">,</span> <span class="n">smax</span><span class="p">)</span>
        <span class="n">arange</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">BINS</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">],</span> <span class="n">BINS</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">])</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">BINS</span><span class="p">[</span><span class="s1">&#39;Nbins&#39;</span><span class="p">]</span>

        <span class="c1"># get edges by doing a fake run</span>
        <span class="n">grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span>
                                             <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">arange</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">midpoints</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">e</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">midpoints</span><span class="p">)</span>
        <span class="n">n_frames</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># histogram individually, and smear out at the same time</span>
            <span class="c1"># with the appropriate B-factor</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">bfactors</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">):</span>
                <span class="n">wmsg</span> <span class="o">=</span> <span class="s2">&quot;Some B-factors are Zero (will be skipped).&quot;</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">wmsg</span><span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">wmsg</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">MissingDataWarning</span><span class="p">)</span>
            <span class="n">rmsf</span> <span class="o">=</span> <span class="n">Bfactor2RMSF</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">bfactors</span><span class="p">)</span>
            <span class="n">grid</span> <span class="o">*=</span> <span class="mf">0.0</span>  <span class="c1"># reset grid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smear_rmsf</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span> <span class="n">rmsf</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># histogram &#39;delta functions&#39;</span>
            <span class="n">grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">arange</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Histogrammed {0:6d} atoms from pdb.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">atoms</span><span class="p">)))</span>
            <span class="c1"># just a convolution of the density with a Gaussian</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smear_sigma</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;pdb&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdb</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;pdb&#39;</span><span class="p">:</span> <span class="n">pdb</span><span class="p">}</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;atomselection&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atomselection</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;n_frames&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_frames</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Histogram completed (initial density in Angstrom**-3)&quot;</span><span class="p">)</span>

        <span class="c1"># Density automatically converts histogram to density for isDensity=False -- ??[OB]</span>

<div class="viewcode-block" id="BfactorDensityCreator.Density"><a class="viewcode-back" href="../../../documentation_pages/analysis/density.html#MDAnalysis.analysis.density.BfactorDensityCreator.Density">[docs]</a>    <span class="k">def</span> <span class="nf">Density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a Density object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">Density</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="s1">&#39;Angstrom&#39;</span><span class="p">),</span>
                    <span class="n">parameters</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">isDensity</span><span class="o">=</span><span class="bp">False</span><span class="p">),</span> <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">make_density</span><span class="p">()</span>
        <span class="n">d</span><span class="o">.</span><span class="n">convert_density</span><span class="p">(</span><span class="s1">&#39;water&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span></div>

    <span class="k">def</span> <span class="nf">_smear_sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="c1"># smear out points</span>
        <span class="c1"># (not optimized -- just to test the principle; faster approach could use</span>
        <span class="c1"># convolution of the whole density with a single Gaussian via FFTs:</span>
        <span class="c1"># rho_smeared = F^-1[ F[g]*F[rho] ]</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># holds the smeared out density</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">grid</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># position in histogram (as bin numbers)</span>
        <span class="k">for</span> <span class="n">iwat</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>  <span class="c1"># super-ugly loop</span>
            <span class="n">p</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">wp</span><span class="p">[</span><span class="n">iwat</span><span class="p">]</span> <span class="k">for</span> <span class="n">wp</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">])</span>
            <span class="n">g</span> <span class="o">+=</span> <span class="n">grid</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussian</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Smearing out atom position {0:4d}/{1:5d} with RMSF {2:4.2f} A</span><span class="se">\r</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iwat</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">sigma</span><span class="p">),)</span>
        <span class="k">return</span> <span class="n">g</span>

    <span class="k">def</span> <span class="nf">_smear_rmsf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">rmsf</span><span class="p">):</span>
        <span class="c1"># smear out each water with its individual Gaussian</span>
        <span class="c1"># (slower than smear_sigma)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># holds the smeared out density</span>
        <span class="n">N</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">for</span> <span class="n">iwat</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coordinates</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">rmsf</span><span class="p">[</span><span class="n">iwat</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">g</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gaussian_cartesian</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">,</span>
                                    <span class="n">c</span><span class="o">=</span><span class="n">coord</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">rmsf</span><span class="p">[</span><span class="n">iwat</span><span class="p">])</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Smearing out atom position {0:4d}/{1:5d} with RMSF {2:4.2f} A</span><span class="se">\r</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iwat</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">rmsf</span><span class="p">[</span><span class="n">iwat</span><span class="p">]),)</span>
        <span class="k">return</span> <span class="n">g</span>

    <span class="k">def</span> <span class="nf">_gaussian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="c1"># i,j,k can be numpy arrays</span>
        <span class="c1"># p is center of gaussian as grid index, sigma its width (in A)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># in Angstrom</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span> <span class="o">*</span> <span class="n">z</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_gaussian_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="c1"># i,j,k can be numpy arrays</span>
        <span class="c1"># c is center of gaussian in cartesian coord (A), sigma its width (in A)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">i</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># in Angstrom</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">j</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">k</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span> <span class="o">*</span> <span class="n">z</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">))</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.14.1-dev0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2005-2015, Naveen Michaud-Agrawal, Elizabeth J. Denning, Christian Beckstein (logo), Joshua L. Adelman, Balasubramanian, Jonathan Barnoud, Alejandro Bernardin, Bart Bruininks, Sbastien Buchoux, David Caplan, Matthieu Chavent, John Detlefs, Xavier Deupi, Jan Domanski, David L. Dotson, Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar, Abhinav Gupta, Benjamin Hall, Kyle J. Huston, Joe Jordan, Max Linke, Jinju Lu, Robert McGibbon, Manuel Nuno Melo, Alex Nesterenko, Hai Nguyen, Mattia F. Palermo, Danny Parton, Joshua L. Phillips, Tyler Reddy, Paul Rigor, Carlos Yanez S., Utkarsh Saxena, Sean L. Seyler, Andy Somogyi, Caio S. Souza, Lukas Stelzl, Gorman Stock, Isaac Virshup, Zhuyi Xue, and Oliver Beckstein.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.5.
    </div>
  </body>
</html>